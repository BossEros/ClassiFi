import { eq, and, desc, sql, count, ilike, or } from "drizzle-orm"
import {
  classes,
  enrollments,
  users,
  type Class,
  type NewClass,
} from "@/models/index.js"
import { BaseRepository } from "@/repositories/base.repository.js"
import { injectable } from "tsyringe"
import { filterUndefined } from "@/shared/utils.js"
import type { PaginatedResult } from "@/modules/users/user.repository.js"
import type {
  CreateClassData as AdminCreateClassData,
  UpdateClassData,
  ClassFilterOptions,
} from "@/services/admin/admin.types.js"

/**
 * Data required to create a new class in the repository.
 * Extends admin CreateClassData with classCode which is generated by the service layer.
 */
export interface CreateClassData extends AdminCreateClassData {
  classCode: string
}

/**
 * Repository for class-related database operations.
 */
@injectable()
export class ClassRepository extends BaseRepository<
  typeof classes,
  Class,
  NewClass
> {
  constructor() {
    super(classes)
  }

  /** Get a class by ID */
  async getClassById(classId: number): Promise<Class | undefined> {
    return await this.findById(classId)
  }

  /** Get a class by class code */
  async getClassByCode(classCode: string): Promise<Class | undefined> {
    const results = await this.db
      .select()
      .from(classes)
      .where(eq(classes.classCode, classCode))
      .limit(1)

    return results[0]
  }

  /** Get all classes taught by a teacher */
  async getClassesByTeacher(
    teacherId: number,
    activeOnly: boolean = true,
  ): Promise<Class[]> {
    if (activeOnly) {
      return await this.db
        .select()
        .from(classes)
        .where(
          and(eq(classes.teacherId, teacherId), eq(classes.isActive, true)),
        )
        .orderBy(desc(classes.createdAt))
    }

    return await this.db
      .select()
      .from(classes)
      .where(eq(classes.teacherId, teacherId))
      .orderBy(desc(classes.createdAt))
  }

  /** Get most recent classes taught by a teacher */
  async getRecentClassesByTeacher(
    teacherId: number,
    limit: number = 5,
  ): Promise<Class[]> {
    return await this.db
      .select()
      .from(classes)
      .where(and(eq(classes.teacherId, teacherId), eq(classes.isActive, true)))
      .orderBy(desc(classes.createdAt))
      .limit(limit)
  }

  /**
   * Get recent classes by teacher WITH student counts in a single query.
   * Optimized to avoid N+1 query problem.
   */
  async getRecentClassesWithStudentCounts(
    teacherId: number,
    limit: number = 5,
  ): Promise<(Class & { studentCount: number })[]> {
    const studentCountSubquery = this.db
      .select({
        classId: enrollments.classId,
        count: sql<number>`count(*)`.as("count"),
      })
      .from(enrollments)
      .groupBy(enrollments.classId)
      .as("student_counts")

    const results = await this.db
      .select({
        id: classes.id,
        teacherId: classes.teacherId,
        className: classes.className,
        classCode: classes.classCode,
        description: classes.description,
        yearLevel: classes.yearLevel,
        semester: classes.semester,
        academicYear: classes.academicYear,
        schedule: classes.schedule,
        createdAt: classes.createdAt,
        isActive: classes.isActive,
        studentCount: sql<number>`COALESCE(${studentCountSubquery.count}, 0)`,
      })
      .from(classes)
      .leftJoin(
        studentCountSubquery,
        eq(classes.id, studentCountSubquery.classId),
      )
      .where(and(eq(classes.teacherId, teacherId), eq(classes.isActive, true)))
      .orderBy(desc(classes.createdAt))
      .limit(limit)

    return results.map((r) => ({
      ...r,
      studentCount: Number(r.studentCount),
    }))
  }

  /**
   * Get all classes by teacher WITH student counts in a single query.
   * Optimized to avoid N+1 query problem.
   */
  async getClassesWithStudentCounts(
    teacherId: number,
    activeOnly: boolean = true,
  ): Promise<(Class & { studentCount: number })[]> {
    const studentCountSubquery = this.db
      .select({
        classId: enrollments.classId,
        count: sql<number>`count(*)`.as("count"),
      })
      .from(enrollments)
      .groupBy(enrollments.classId)
      .as("student_counts")

    const condition = activeOnly
      ? and(eq(classes.teacherId, teacherId), eq(classes.isActive, true))
      : eq(classes.teacherId, teacherId)

    const results = await this.db
      .select({
        id: classes.id,
        teacherId: classes.teacherId,
        className: classes.className,
        classCode: classes.classCode,
        description: classes.description,
        yearLevel: classes.yearLevel,
        semester: classes.semester,
        academicYear: classes.academicYear,
        schedule: classes.schedule,
        createdAt: classes.createdAt,
        isActive: classes.isActive,
        studentCount: sql<number>`COALESCE(${studentCountSubquery.count}, 0)`,
      })
      .from(classes)
      .leftJoin(
        studentCountSubquery,
        eq(classes.id, studentCountSubquery.classId),
      )
      .where(condition)
      .orderBy(desc(classes.createdAt))

    return results.map((r) => ({
      ...r,
      studentCount: Number(r.studentCount),
    }))
  }

  /** Create a new class */
  async createClass(data: CreateClassData): Promise<Class> {
    const results = await this.db
      .insert(classes)
      .values({
        teacherId: data.teacherId,
        className: data.className,
        classCode: data.classCode,
        yearLevel: data.yearLevel,
        semester: data.semester,
        academicYear: data.academicYear,
        schedule: data.schedule,
        description: data.description ?? null,
        isActive: true,
      })
      .returning()

    return results[0]
  }

  /** Update a class */
  async updateClass(
    classId: number,
    data: UpdateClassData,
  ): Promise<Class | undefined> {
    const updateData = filterUndefined(data)

    if (Object.keys(updateData).length === 0) {
      return await this.getClassById(classId)
    }

    return await this.update(classId, updateData)
  }

  /** Delete a class (hard delete) */
  async deleteClass(classId: number): Promise<boolean> {
    return await this.delete(classId)
  }

  /** Get the number of students in a class */
  async getStudentCount(classId: number): Promise<number> {
    const result = await this.db
      .select({ count: sql<number>`count(*)` })
      .from(enrollments)
      .where(eq(enrollments.classId, classId))

    return Number(result[0]?.count ?? 0)
  }

  /** Check if a class code already exists */
  async checkClassCodeExists(classCode: string): Promise<boolean> {
    const results = await this.db
      .select({ id: classes.id })
      .from(classes)
      .where(eq(classes.classCode, classCode))
      .limit(1)

    return results.length > 0
  }

  /** Get all classes a student is enrolled in */
  async getClassesByStudent(
    studentId: number,
    activeOnly: boolean = true,
  ): Promise<Class[]> {
    const query = this.db
      .select({
        id: classes.id,
        teacherId: classes.teacherId,
        className: classes.className,
        classCode: classes.classCode,
        description: classes.description,
        yearLevel: classes.yearLevel,
        semester: classes.semester,
        academicYear: classes.academicYear,
        schedule: classes.schedule,
        createdAt: classes.createdAt,
        isActive: classes.isActive,
      })
      .from(enrollments)
      .innerJoin(classes, eq(enrollments.classId, classes.id))
      .where(
        activeOnly
          ? and(
              eq(enrollments.studentId, studentId),
              eq(classes.isActive, true),
            )
          : eq(enrollments.studentId, studentId),
      )
      .orderBy(desc(classes.createdAt))

    return await query
  }

  /**
   * Get all classes a student is enrolled in WITH student counts and teacher info.
   * Optimized to avoid N+1 query problem.
   */
  async getClassesByStudentWithDetails(
    studentId: number,
    activeOnly: boolean = true,
  ): Promise<(Class & { studentCount: number; teacherName: string })[]> {
    const studentCountSubquery = this.db
      .select({
        classId: enrollments.classId,
        count: sql<number>`count(*)`.as("count"),
      })
      .from(enrollments)
      .groupBy(enrollments.classId)
      .as("student_counts")

    const condition = activeOnly
      ? and(eq(enrollments.studentId, studentId), eq(classes.isActive, true))
      : eq(enrollments.studentId, studentId)

    const results = await this.db
      .select({
        id: classes.id,
        teacherId: classes.teacherId,
        className: classes.className,
        classCode: classes.classCode,
        description: classes.description,
        yearLevel: classes.yearLevel,
        semester: classes.semester,
        academicYear: classes.academicYear,
        schedule: classes.schedule,
        createdAt: classes.createdAt,
        isActive: classes.isActive,
        studentCount: sql<number>`COALESCE(${studentCountSubquery.count}, 0)`,
        teacherFirstName: users.firstName,
        teacherLastName: users.lastName,
      })
      .from(enrollments)
      .innerJoin(classes, eq(enrollments.classId, classes.id))
      .innerJoin(users, eq(classes.teacherId, users.id))
      .leftJoin(
        studentCountSubquery,
        eq(classes.id, studentCountSubquery.classId),
      )
      .where(condition)
      .orderBy(desc(classes.createdAt))

    return results.map((r) => ({
      ...r,
      studentCount: Number(r.studentCount),
      teacherName: `${r.teacherFirstName} ${r.teacherLastName}`,
    }))
  }

  /**
   * Get all classes with pagination and filters.
   * Moved from AdminService to follow DIP.
   */
  async getAllClassesFiltered(
    options: ClassFilterOptions,
  ): Promise<
    PaginatedResult<Class & { studentCount: number; teacherName?: string }>
  > {
    const {
      page,
      limit,
      search,
      teacherId,
      status,
      yearLevel,
      semester,
      academicYear,
    } = options
    const offset = (page - 1) * limit

    // Build where conditions
    const conditions: ReturnType<typeof eq>[] = []

    if (search) {
      conditions.push(
        or(
          ilike(classes.className, `%${search}%`),
          ilike(classes.classCode, `%${search}%`),
          ilike(classes.description, `%${search}%`),
        )!,
      )
    }

    if (teacherId) {
      conditions.push(eq(classes.teacherId, teacherId))
    }

    if (status === "active") {
      conditions.push(eq(classes.isActive, true))
    } else if (status === "archived") {
      conditions.push(eq(classes.isActive, false))
    }

    if (yearLevel) {
      conditions.push(eq(classes.yearLevel, yearLevel))
    }

    if (semester) {
      conditions.push(eq(classes.semester, semester))
    }

    if (academicYear) {
      conditions.push(eq(classes.academicYear, academicYear))
    }

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined

    // Get total count
    const countResult = await this.db
      .select({ count: count() })
      .from(classes)
      .where(whereClause)

    const total = Number(countResult[0]?.count ?? 0)

    // Get paginated data with teacher info
    const studentCountSubquery = this.db
      .select({
        classId: enrollments.classId,
        count: sql<number>`count(*)`.as("count"),
      })
      .from(enrollments)
      .groupBy(enrollments.classId)
      .as("student_counts")

    const data = await this.db
      .select({
        id: classes.id,
        teacherId: classes.teacherId,
        className: classes.className,
        classCode: classes.classCode,
        description: classes.description,
        yearLevel: classes.yearLevel,
        semester: classes.semester,
        academicYear: classes.academicYear,
        schedule: classes.schedule,
        createdAt: classes.createdAt,
        isActive: classes.isActive,
        studentCount: sql<number>`COALESCE(${studentCountSubquery.count}, 0)`,
        teacherName: sql<string>`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
      })
      .from(classes)
      .leftJoin(
        studentCountSubquery,
        eq(classes.id, studentCountSubquery.classId),
      )
      .leftJoin(users, eq(classes.teacherId, users.id))
      .where(whereClause)
      .orderBy(desc(classes.createdAt))
      .limit(limit)
      .offset(offset)

    return {
      data: data.map((r) => ({
        ...r,
        studentCount: Number(r.studentCount),
      })),
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    }
  }

  /**
   * Get a class with teacher name.
   * Used by admin views.
   */
  async getClassWithTeacher(
    classId: number,
  ): Promise<(Class & { teacherName: string }) | undefined> {
    const results = await this.db
      .select({
        id: classes.id,
        teacherId: classes.teacherId,
        className: classes.className,
        classCode: classes.classCode,
        description: classes.description,
        yearLevel: classes.yearLevel,
        semester: classes.semester,
        academicYear: classes.academicYear,
        schedule: classes.schedule,
        createdAt: classes.createdAt,
        isActive: classes.isActive,
        teacherName: sql<string>`COALESCE(CONCAT(${users.firstName}, ' ', ${users.lastName}), 'Unknown')`,
      })
      .from(classes)
      .leftJoin(users, eq(classes.teacherId, users.id))
      .where(eq(classes.id, classId))
      .limit(1)

    return results[0] as (Class & { teacherName: string }) | undefined
  }

  /**
   * Get class counts (total and active).
   * Used for admin analytics dashboard.
   */
  async getClassCounts(): Promise<{ total: number; active: number }> {
    const totalResult = await this.db.select({ count: count() }).from(classes)
    const activeResult = await this.db
      .select({ count: count() })
      .from(classes)
      .where(eq(classes.isActive, true))

    return {
      total: Number(totalResult[0]?.count ?? 0),
      active: Number(activeResult[0]?.count ?? 0),
    }
  }

  /**
   * Get most recent classes with teacher info.
   * Used for admin activity feed.
   */
  async getRecentClassesWithTeacher(limit: number = 10): Promise<
    Array<{
      class: Class
      teacherName: string
    }>
  > {
    const results = await this.db
      .select({
        class: classes,
        teacher: users,
      })
      .from(classes)
      .leftJoin(users, eq(classes.teacherId, users.id))
      .orderBy(desc(classes.createdAt))
      .limit(limit)

    return results.map((row) => ({
      class: row.class,
      teacherName: row.teacher
        ? `${row.teacher.firstName} ${row.teacher.lastName}`
        : "Unknown",
    }))
  }
}
